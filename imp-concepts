1.⁠ ⁠𝐁𝐢𝐧𝐚𝐫𝐲 𝐒𝐞𝐚𝐫𝐜𝐡 𝐨𝐧 𝐀𝐧𝐬𝐰𝐞𝐫: Use for finding min/max or optimization problems.
2.⁠ ⁠𝐃𝐲𝐧𝐚𝐦𝐢𝐜 𝐏𝐫𝐨𝐠𝐫𝐚𝐦𝐦𝐢𝐧𝐠 (𝐃𝐏): Solve problems with overlapping subproblems (e.g., paths, grids).
3.⁠ ⁠𝐏𝐫𝐢𝐨𝐫𝐢𝐭𝐲 𝐐𝐮𝐞𝐮𝐞: Find the top, smallest, or most frequent 'K' elements.
4.⁠ ⁠𝐒𝐥𝐢𝐝𝐢𝐧𝐠 𝐖𝐢𝐧𝐝𝐨𝐰: Solve for longest/shortest subarray or substring.
5.⁠ ⁠𝐓𝐰𝐨 𝐏𝐨𝐢𝐧𝐭𝐞𝐫𝐬: Efficiently find pairs or iterate through sequences.
6.⁠ ⁠𝐆𝐫𝐞𝐞𝐝𝐲 𝐀𝐥𝐠𝐨𝐫𝐢𝐭𝐡𝐦𝐬: Make locally optimal choices for a global solution.
7.⁠ ⁠𝐁𝐚𝐜𝐤𝐭𝐫𝐚𝐜𝐤𝐢𝐧𝐠: Explore all possibilities (e.g., permutations, mazes).
8.⁠ ⁠𝐔𝐧𝐢𝐨𝐧 𝐅𝐢𝐧𝐝 / 𝐃𝐢𝐬𝐣𝐨𝐢𝐧𝐭 𝐒𝐞𝐭: Manage graph connectivity, detect cycles.
9.⁠ ⁠𝐁𝐢𝐭 𝐌𝐚𝐧𝐢𝐩𝐮𝐥𝐚𝐭𝐢𝐨𝐧: Solve problems with bits (e.g., counting set bits).
10.⁠ ⁠𝐌𝐚𝐭𝐫𝐢𝐱 𝐓𝐫𝐚𝐯𝐞𝐫𝐬𝐚𝐥: Solve problems with 2D grids (e.g., pathfinding).

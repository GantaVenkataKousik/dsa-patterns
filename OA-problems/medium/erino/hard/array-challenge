
Have the function ArrayChallenge (strArr)
read the strArr parameter being passed which will represent the relations among people standing in a line. The structure of the input will be ["A>B","B>C","A<D",etc..]. The letters stand for different people and the greater than and less than signs stand for a person being in front of someone or behind someone. A>B means A is in front of B and B<C means that B is behind C in line. For example if strArr is: ["J>B","B<S","D>p"], these are the following ways you can arrange the people in line: DSJB, SDJB and DJSB. Your program will determine the number of ways people can be arranged in line. So for this example your program should return the number 3. It also may be the case that the relations produce an impossible line ordering, resulting in zero as the answer.
Only the symbols <, >, and the uppercase letters A...Z will be used. The maximum number of
relations strArr will contain is ten.
Examples
Input: ["A>B","A< C", "C< Z"]
Output: 1

import java.util.*;

public class Main {

    public static int countArrangements(String[] strArr) {
        // Parse input relations to build a graph and indegree map
        Map<Character, List<Character>> graph = new HashMap<>();
        Map<Character, Integer> indegree = new HashMap<>();
        
        for (String relation : strArr) {
            char person1 = relation.charAt(0);
            char person2 = relation.charAt(2);
            char sign = relation.charAt(1);

            // Initialize graph nodes and indegree entries
            graph.putIfAbsent(person1, new ArrayList<>());
            graph.putIfAbsent(person2, new ArrayList<>());
            indegree.putIfAbsent(person1, 0);
            indegree.putIfAbsent(person2, 0);

            // Add directed edges based on relations
            if (sign == '>') {
                graph.get(person1).add(person2);
                indegree.put(person2, indegree.get(person2) + 1);
            } else if (sign == '<') {
                graph.get(person2).add(person1);
                indegree.put(person1, indegree.get(person1) + 1);
            }
        }

        // Use backtracking to find all valid topological orders, avoiding duplicates
        Set<String> uniqueOrders = new HashSet<>();
        findAllTopologicalOrders(graph, indegree, new ArrayList<>(), uniqueOrders);

        // Return the count of unique valid arrangements
        return uniqueOrders.size();
    }

    private static void findAllTopologicalOrders(
        Map<Character, List<Character>> graph,
        Map<Character, Integer> indegree,
        List<Character> currentOrder,
        Set<String> uniqueOrders
    ) {
        boolean added = false;
        
        for (Character node : indegree.keySet()) {
            if (indegree.get(node) == 0) { // Node with zero indegree can be placed next
                added = true;
                currentOrder.add(node);
                indegree.put(node, indegree.get(node) - 1);

                for (Character neighbor : graph.get(node)) {
                    indegree.put(neighbor, indegree.get(neighbor) - 1);
                }

                // Recursive call to continue building the order
                findAllTopologicalOrders(graph, indegree, currentOrder, uniqueOrders);

                // Backtrack
                currentOrder.remove(currentOrder.size() - 1);
                indegree.put(node, indegree.get(node) + 1);
                for (Character neighbor : graph.get(node)) {
                    indegree.put(neighbor, indegree.get(neighbor) + 1);
                }
            }
        }

        if (!added && currentOrder.size() == indegree.size()) {
            // Convert current ordering to string and add to unique orders
            StringBuilder order = new StringBuilder();
            for (Character c : currentOrder) {
                order.append(c);
            }
            uniqueOrders.add(order.toString());
        }
    }

    public static void main(String[] args) {  
        // Example input
        String[] strArr = {"A>B","A< C","C< Z"};
        System.out.println(countArrangements(strArr)); // Should output 1
    }
}
